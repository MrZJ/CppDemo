#C++内存分布
    #栈区（stack）
        1、非静态的局部变量当程序运行时分配内存
        2、栈区上的变量分三个部分组成：变量名字，保存的值，栈内存的地址
        3、定义处生命开始
        4、当函数运行结束时，该非今天变量被释放
        5、由高到低分配内存
        6、分配连续的内存
    #堆区(heap)
        1、new People(),malloc(sizeof(People))
        2、堆上的变量由 保存的值 和 堆内存地址 组成
        3、因为没有名字所以得用栈区的指针变量来操作
        4、运行时分配内存
        5、从new处开始，从delete结束
        6、由低到高分配，动态内存的生命周期由人为决定，使用灵活，但容易出现内存泄漏（频繁的分配和回收会产生很多内存碎片）
        7、可以分配不连续的内存
    #静态区（static）
        1、全局变量、static变量（全局和局部）
           a.静态局部变量只在编译时赋值一次，后面方法调用时不进行赋值
           b.全局变量有默认初始值 0
        2、代码编译时分配内存，程序结束后释放内存
    #常量区
        1、放常量
    #代码区
        1、放代码
#C++引用(给变量取别名)
    语法：Type &别名 = 原名
        exp:int a = 10; int &b = a;
    1、引用必须初始化
    2、引用一但初始化后就不能再更改了
    3、如果函数的返回值是引用，那这个函数可以作为左值
#常量引用
    使用场景：用来修饰形参，防止误操作
#C++函数
    1、函数不要返回局部变量的地址和引用，因为局部变量存在栈区，当方法执行完，局部变量就会被回收
#C++访问权限
    1、public（公共的）：被修饰的成员，类内可以访问，类外也可以访问
    2、protected（保护的）：被修饰的成员，类内可以访问，类外不可以访问
    3、private（私有的）：被修饰的成员，类内可以访问，类外不可以访问
    tips:protected与private的区别主要在继承，protected修饰的成员可以被子类访问，但是private修饰的成员不可以
#C++ struct和class
    C++中struct和class的唯一区别是默认的访问权限不同，struct：默认权限为public，class:为private
    C里面的struct没有函数，只有属性
#C++构造函数
    默认情况下，C++编译器至少给一个类添加三个构造函数：
        a.默认无参构造函数
        b.默认析构函数
        c.默认拷贝函数，对属性进行拷贝
    构造函数调用规则：
        1、如果定义了有参构造函数，C++则不再提供无参构造函数，但是依然会提供拷贝构造函数
        2、如果定义了拷贝构造函数，C++不会再提供其他构造函数
    初始化列表初始化属性：
        构造函数 exp：
            Person():m_Age(10),mName("jack"){
            }
#C++深拷贝和浅拷贝
    深拷贝：在堆区重新申请空间，进行拷贝操作
    浅拷贝：简单的赋值操作
#常函数和常对象
    常函数定义：成员函数后加const修饰，常函数只能修改mutable修饰的成员属性
    常对象：声明对象前加const修饰，常对象只能调用常函数
#友元
    目的：让一个函数或类访问另一个类的私有成员
    关键字是friend
    实现方式：
    1、全局函数做友元
    2、类做友元
    3、成员函数做友元
    class People{
        //全局函数做友元exp:
        friend void getName(People *p);//这样getName就可以访问People的私有属性了
        //类做友元
        friend class GoodFriend;
        //成员函数做友元
        friend void GoodFriend::visit();
    private:
        string name;
    }
    void getName(People *p){
       string name = p->name;
    }
#运算符重载
    1、通过成员函数重载+号
    exp:
    T operator+(Person p){
        //...自定义的一些操作
        // this->age +p.age;
        return T;
    }
    2、通过全局函数重载+号
    T operator+(Person pA,Person bP){
          //...自定义的一些操作
          //pA.age + bp.age;
          return T;
    }
    使用：
        Person p3 = p1.operator+(p2)
        Person p3 = operator+(p1,+p2)
        简化：Person p3 = p1+p2
    （）重载
        因为书写出来特别像一个函数，所以也被叫做仿函数
#C++继承
    语法：子类：访问类型 基类
    访问类型分：public protect private
#C++多态
    #静态多态：重载
    #动态多态满足条件：
        1、有继承关系
        2、子类重写父类的虚函数 virtual
    #动态多态使用：
        父类的指针或引用指向子类的对象
    #好处：
        1、代码组织结构清晰
        2、可读性强
        3、利于前期和后期的维护以及拓展
    纯虚函数语法：virtual 返回值 方法名（参数）=0;
        exp:virtual void speak() = 0;
    #抽象类：
        1、当类中有纯虚函数，那这个类就是抽象类，子类继承自他要实现纯虚函数，不然子类也是抽象类
        2、抽象类无法实例化对象
    #虚析构和纯虚析构
        原因：多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码，会造成内存泄漏
        解决方法：将父类中的析构函数改完虚析构或纯虚析构
#C++文件读写
    步骤：
        1.包含头文件：#include<fstream>;
        2.创建流对象：ofstream ofs;
        3.打开文件：ofs.open("文件路径",打开方式);
            打开方式：
            a.ios::in(为读文件而打开文件)
            b.ios::out(为写文件而打开文件)
            c.ios::ate(初始位置：文件尾)
            d.ios::app(追加方式写文件)
            e.ios::trunc(如果文件存在，先删除，再创建)
            f.ios::binary(二进制方式)
        4.写数据：ofs<<"写入的数据";
        5.关闭文件：ofs.close();
#C++模板
    1、函数模板
        #作用：建立一个通用函数，其函数返回值类型和形参类型可以不具体指定，用一个虚拟的类型来代表
        #语法：
            template<typename T>
            函数声明或定义
            解释：
            template：声明创建模板
            typename：表明其后面的符号是一种数据类型，可以用class代替
            T：通用的数据类型，名称可以替换，通常为大写字母
        #注意事项：
            1、自动类型推导，必须推导一致的类型T才可以使用
            2、模板必须确定T的数据类型，才可以使用
        #普通函数与函数模板的区别
            1、普通函数调用时可以发生自动类型转换（隐式类型转换）
            2、函数模板调用时，如果利用自动推导类型，不会进行隐式类型转换
            3、如果利用显示指定类型的方式，可以发生隐式类型转换
        #普通函数和函数模板的调用规则
            1、如果函数模板和普通函数都可以实现，则优先调用普通函数
            2、可以通过空模板参数列表来强制调用函数模板
            3、函数模板也可以发生重载
            4、如果函数模板可以产生更好的匹配，优先调用函数模板
    2、类模板
        #作用：建立一个通用类，类中的成员数据类型可以不具体制定，用一个虚拟的类型来代表
        #语法
            template<class T>
            类
            解释：
            template：声明创建模板
            typename：表明其后面的符号是一种数据类型，可以用class代替
            T：通用的数据类型，名称可以替换，通常为大写字母
        #成员函数创建时机
            类模板的成员函数在调用时才去创建
    3、类模板和函数模板的区别
        a.类模板没有自动推导的使用方式
        b.类模板在模板参数列表中可以有默认参数